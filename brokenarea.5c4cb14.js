const e="\r\n\r\n```ts\r\nbrokenarea(cell: BrokenAreaCell, [options])\r\n```\r\n\r\nDraws a \"broken cloud,\" or a shape with both a top and bottom value, capable of stopping and reappearing elsewhere without continuity. The `brokenarea` function is flexible enough to create rectangles, background fills, and even horizontal lines, enabling advanced plotting capabilities. When applied correctly, it can generate complex visualizations like heatmaps.\r\n\r\n## Parameters\r\n\r\n- **`cell`** — Defines the primary characteristics of the broken area.\r\n- **`options`** *(optional)* — Allows additional customization, such as color and stroke properties.\r\n\r\n## `BrokenAreaCell` Type\r\n\r\n```ts\r\nexport interface BrokenAreaCell {\r\n  time: number;             // Unix timestamp\r\n  lowerValue: number;\r\n  higherValue: number;\r\n  extendRight?: boolean;\r\n  infinite?: boolean;       // Draw beyond viewport if set to true\r\n  color?: string;\r\n  label?: string;\r\n  id?: string;\r\n}\r\n```\r\n\r\n## `BrokenAreaOptions` Type\r\n\r\n```ts\r\nexport interface BrokenAreaOptions {\r\n  color?: string;\r\n  strokeColor?: string;\r\n  strokeWidth?: number;\r\n}\r\n```\r\n\r\n## Example Usage\r\n\r\n### Basic Example (Suboptimal Usage)\r\n\r\n```\r\nbrokenarea({\r\n  time: time,\r\n  lowerValue: 10,\r\n  higherValue: 20,\r\n  extendRight: true,\r\n  color: 'yellow'\r\n})\r\n```\r\n\r\nThis example draws a rectangle extending infinitely to the right, which can function as a test but lacks practical application.\r\n\r\n### Advanced Example (Dynamic Slot-Based Drawing)\r\n\r\nThe `brokenarea` function is most effective when used to dynamically allocate slots for drawing lines or rectangles on the chart. By defining multiple `brokenarea` slots programmatically, you gain greater control over redrawing and updating visual elements based on script logic.\r\n\r\n```ts\r\n// top of the script\r\nif (!boundaries) {\r\n  // check if boundaries isn't defined = initial run of the script\r\n\r\n  // define some persistent script variables\r\n  pendingRedraws = [] // number[]\r\n  slots = [] // {index: number, redrawAt: number}[]\r\n\r\n  // indicator related, but usefull to underestand the point\r\n  cells = [] // {[normalizedCellPrice: number]: {strength: number, index: number, top: number, bottom: number, count: number}\r\n\r\n  // here we make use of the series global variable\r\n  for (var i = 0; i < series.length; i++) {\r\n    if (series[i].seriesType() !== 'BrokenArea') {\r\n      continue\r\n    }\r\n\r\n    // register each available series as a slot \r\n    slots.push({\r\n      index: i,\r\n      redrawAt: 0\r\n    })\r\n\r\n    // boundaries: { [cellId: string]: *bar index* }\r\n    series[i].setExtensionsBoundaries(boundaries)\r\n  }\r\n}\r\n\r\n// define the slots at whatever part of the script\r\nbrokenarea()\r\nbrokenarea()\r\nbrokenarea()\r\nbrokenarea()\r\nbrokenarea()\r\nbrokenarea()\r\nbrokenarea()\r\nbrokenarea()\r\nbrokenarea()\r\nbrokenarea()\r\nbrokenarea()\r\n```\r\n\r\nThis binds the `boundaries` object to each series slot, allowing control over where each cell extension halts.\r\n\r\n```ts\r\n// at the bottom of the script, you would have something like this\r\n// pendingRedraws here is an array of the cells that needs to be redrawn, each redraw use another object `cells`, a store for all the cells\r\nif (pendingRedraws.length) {\r\n  for (var i = 0; i < pendingRedraws.length; i++) {\r\n    var cell = cells[pendingRedraws[i]]\r\n\r\n    if (!cell) {\r\n      // maybe cell doesn't exist anymore\r\n      pendingRedraws.splice(i--, 1)\r\n      continue\r\n    }\r\n    \r\n    var slot = slots.find(slot => slot.redrawAt < bar.length)\r\n\r\n    if (slot) {\r\n      // lock that slot to NOT be used until next bar\r\n      slot.redrawAt = bar.length + 1\r\n\r\n      if (cell.id) {\r\n        // this is the interesting part. it tells the cell previously drawn by that slot (with extendRight: true) to stop extending at the bar index `bar.length - 2`\r\n        boundaries[cell.id] = bar.length - 2\r\n      }\r\n      \r\n      // register a new cell id\r\n      cell.id = Math.random().toString()\r\n\r\n      // indicator related stuff based on our cell\r\n      var ratio = Math.max(0.01, Math.min(1, cell.strength * cell.count * (options.strength / 100)))\r\n      var color = interpolate(ratio, color0, color1, color2, color3)\r\n\r\n      // this is the second interesting part. it just tells the selected brokenarea() slot (bar.series[series[slot.index].id]) to draw the rectangle\r\n      bar.series[series[slot.index].id] ={\r\n        id: cell.id,\r\n        time: time - bar.timeframe,\r\n        lowerValue: cell.top,\r\n        higherValue: cell.bottom,\r\n        extendRight: true,\r\n        color: color\r\n      }\r\n\r\n      pendingRedraws.splice(i--, 1)\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis setup provides efficient control over drawing, only updating cells that have changed. With proper configuration, this approach forms the basis for heatmap visualizations by selectively redrawing areas as needed.\r\n\r\n### Horizontal lines\r\n\r\nThe `brokenarea` function can also create horizontal lines, offering programmable and efficient rendering. Setting `lowerValue` and `higherValue` to the same value draws a line instead of a rectangle.\r\n\r\nExample: Drawing a horizontal threshold line above a histogram series.\r\n\r\n```ts\r\nthreshold = option(default=1000000,type=range,step=10000,min=1000,max=10000000)\r\nbrokenarea(infinite=true,strokeWidth=0.5,strokeColor=options.upColor,id=threshold)\r\n\r\nif (bar.length === 1) {\r\n  // draw once\r\n  bar.series.threshold = { time: time, lowerValue: options.threshold, higherValue: options.threshold, extendRight: true }\r\n}\r\n```\r\n\r\nWith `brokenarea`, precise control over plot boundaries and appearance is possible, enabling a high degree of customization across various charting applications.\r\n";export{e as default};
